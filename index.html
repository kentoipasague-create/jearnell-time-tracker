<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Jearnell Ken Time Tracker</title>

<style>
  body { font-family: Arial, sans-serif; margin:0; padding:0; background:#f5f5f5; }
  header { background:#1e3a8a; color:white; padding:20px; text-align:center; }
  .container { max-width:980px; margin:20px auto; background:white; padding:20px; border-radius:10px; }
  input, select, button { padding:10px; margin:5px 0; border-radius:5px; border:1px solid #ccc; }
  button { background:#1e3a8a; color:white; border:none; cursor:pointer; }
  button:disabled { opacity:.6; cursor:not-allowed; }
  table { width:100%; border-collapse: collapse; margin-top:20px; }
  th, td { border:1px solid #ddd; padding:8px; text-align:left; vertical-align: top; }
  th { background:#f0f0f0; }

  /* ACTION DROPDOWN */
  .action-wrap { position:relative; display:inline-block; }
  .action-btn { padding:8px 12px; font-weight:600; }

  .dropdown {
    position:absolute; right:0; top:42px;
    background:#fff; border:1px solid #ddd; border-radius:10px;
    box-shadow:0 10px 25px rgba(0,0,0,.15);
    min-width:170px; display:none; z-index:100; overflow:hidden;
  }
  .dropdown.open { display:block; }
  .dropdown button {
    width:100%;
    background:none;
    color:#111;
    border:none;
    padding:10px 12px;
    text-align:left;
    margin:0;
  }
  .dropdown button:hover { background:#f3f4f6; }
  .dropdown .danger { color:#b91c1c; }
  .dropdown hr { margin:0; border:none; height:1px; background:#eee; }

  /* EDIT MODAL */
  .backdrop{
    position:fixed; inset:0; background:rgba(0,0,0,.45);
    display:none; align-items:center; justify-content:center;
    z-index:1000; padding:16px;
  }
  .backdrop.show{ display:flex; }
  .modal{
    width:100%; max-width:620px;
    background:#fff; border-radius:14px;
    box-shadow:0 20px 50px rgba(0,0,0,.25);
    padding:16px;
  }
  .modal h3{ margin:0 0 10px 0; }
  .grid{ display:flex; gap:12px; flex-wrap:wrap; }
  .field{ flex:1; min-width:260px; }
  .modal label{ display:block; font-size:12px; color:#444; margin:8px 0 4px; }
  .modal input, .modal select { width:100%; box-sizing:border-box; }
  .hint{ font-size:12px; color:#555; margin-top:6px; line-height:1.35; }
  .modal-actions{ display:flex; justify-content:flex-end; gap:10px; margin-top:14px; }
  .btn-secondary{ background:#e5e7eb; color:#111; border:1px solid #d1d5db; }
</style>
</head>

<body>
<header>
  <h1>Jearnell Ken Time Tracker</h1>
</header>

<div class="container">
  <h2>Add Task</h2>
  <input type="text" id="taskName" placeholder="Task Name" />
  <select id="taskCategory">
    <option value="Work">Work</option>
    <option value="Study">Study</option>
    <option value="Exercise">Exercise</option>
    <option value="Other">Other</option>
  </select>
  <button onclick="startTask()">Start Task</button>

  <h2>Tasks</h2>
  <table>
    <thead>
      <tr>
        <th>Task</th>
        <th>Category</th>
        <th>Start</th>
        <th>End</th>
        <th>Duration</th>
        <th>Action</th>
      </tr>
    </thead>
    <tbody id="tasksTable"></tbody>
  </table>
</div>

<!-- EDIT MODAL -->
<div id="editBackdrop" class="backdrop" onclick="closeEditModal(event)">
  <div class="modal" onclick="event.stopPropagation()">
    <h3>Edit Task (Fix Time)</h3>

    <div class="grid">
      <div class="field">
        <label>Task Name</label>
        <input id="editName" type="text" />
      </div>

      <div class="field">
        <label>Category</label>
        <select id="editCategory">
          <option value="Work">Work</option>
          <option value="Study">Study</option>
          <option value="Exercise">Exercise</option>
          <option value="Other">Other</option>
        </select>
      </div>

      <div class="field">
        <label>Start (local)</label>
        <input id="editStart" type="datetime-local" />
      </div>

      <div class="field">
        <label>End (local) — optional</label>
        <input id="editEnd" type="datetime-local" />
      </div>

      <div class="field">
        <label>Duration (HH:MM:SS) — optional</label>
        <input id="editDuration" type="text" placeholder="00:30:00" />
        <div class="hint">
          You can fix mistakes either by setting <b>Start + End</b> (Duration auto-calculates)
          or setting <b>Start + Duration</b> (End auto-calculates). If you fill both End and Duration,
          End wins.
        </div>
      </div>
    </div>

    <div class="modal-actions">
      <button class="btn-secondary" onclick="closeEditModal()">Cancel</button>
      <button onclick="saveEdit()">Save</button>
    </div>
  </div>
</div>

<script>
/*
New task shape:
{
  name, category,
  createdAtISO,           // Start
  endISO: string|null,    // End (set when stopped or edited)
  status: "running" | "paused" | "stopped",
  lastStartISO: string|null, // when it last started/resumed (only if running)
  elapsedMs: number          // accumulated duration while paused/stopped + completed chunks
}
*/

let tasks = JSON.parse(localStorage.getItem('tasks') || '[]');

/* ✅ One-time migration: old {start,end} format -> new format */
tasks = tasks.map(t => {
  // already new format
  if ('elapsedMs' in t && 'createdAtISO' in t) return t;

  const start = new Date(t.start);
  const end = t.end ? new Date(t.end) : null;

  let elapsedMs = 0;
  let status = 'stopped';
  let lastStartISO = null;
  let endISO = null;

  if (end) {
    elapsedMs = end.getTime() - start.getTime();
    status = 'stopped';
    endISO = end.toISOString();
  } else {
    // old code had a running task with end = null
    elapsedMs = Date.now() - start.getTime();
    status = 'running';
    lastStartISO = new Date().toISOString();
    endISO = null;
  }

  return {
    name: t.name,
    category: t.category || 'Other',
    createdAtISO: start.toISOString(),
    endISO,
    status,
    lastStartISO,
    elapsedMs: Math.max(0, elapsedMs)
  };
});
localStorage.setItem('tasks', JSON.stringify(tasks));

function save() {
  localStorage.setItem('tasks', JSON.stringify(tasks));
  render();
}

/* ---------- time helpers ---------- */
function formatDuration(ms) {
  ms = Math.max(0, ms);
  const totalSeconds = Math.floor(ms / 1000);
  const hrs = String(Math.floor(totalSeconds / 3600)).padStart(2,'0');
  const mins = String(Math.floor((totalSeconds % 3600) / 60)).padStart(2,'0');
  const secs = String(totalSeconds % 60).padStart(2,'0');
  return `${hrs}:${mins}:${secs}`;
}

function parseHHMMSS(str) {
  const s = (str || '').trim();
  if (!s) return null;
  const m = s.match(/^(\d+):([0-5]?\d):([0-5]?\d)$/);
  if (!m) return null;
  const h = parseInt(m[1], 10);
  const min = parseInt(m[2], 10);
  const sec = parseInt(m[3], 10);
  return ((h * 3600) + (min * 60) + sec) * 1000;
}

function getDurationMs(task) {
  const base = task.elapsedMs || 0;
  if (task.status === 'running' && task.lastStartISO) {
    return base + (Date.now() - new Date(task.lastStartISO).getTime());
  }
  return base;
}

/* ---------- dropdown behavior ---------- */
function closeAllDropdowns() {
  document.querySelectorAll('.dropdown.open').forEach(d => d.classList.remove('open'));
}

function toggleDropdown(i) {
  const dd = document.getElementById('dd-' + i);
  if (!dd) return;

  const isOpen = dd.classList.contains('open');
  closeAllDropdowns();
  if (!isOpen) dd.classList.add('open');
}

document.addEventListener('click', e => {
  if (!e.target.closest('.action-wrap')) closeAllDropdowns();
});

/* ---------- task actions ---------- */
function startTask() {
  const name = document.getElementById('taskName').value.trim();
  const category = document.getElementById('taskCategory').value;
  if (!name) return alert('Enter task name');

  const nowISO = new Date().toISOString();

  tasks.push({
    name,
    category,
    createdAtISO: nowISO,
    endISO: null,
    status: 'running',
    lastStartISO: nowISO,
    elapsedMs: 0
  });

  document.getElementById('taskName').value = '';
  save();
}

function pauseTask(i) {
  closeAllDropdowns();
  const t = tasks[i];
  if (!t || t.status !== 'running') return;

  if (t.lastStartISO) {
    t.elapsedMs = (t.elapsedMs || 0) + (Date.now() - new Date(t.lastStartISO).getTime());
  }
  t.status = 'paused';
  t.lastStartISO = null;
  // End stays blank until stopped or edited
  save();
}

function resumeTask(i) {
  closeAllDropdowns();
  const t = tasks[i];
  if (!t || t.status !== 'paused') return;

  t.status = 'running';
  t.lastStartISO = new Date().toISOString();
  // If it was previously stopped/edited with an end, resume should clear end
  t.endISO = null;
  save();
}

function stopTask(i) {
  closeAllDropdowns();
  const t = tasks[i];
  if (!t || t.status === 'stopped') return;

  if (t.status === 'running' && t.lastStartISO) {
    t.elapsedMs = (t.elapsedMs || 0) + (Date.now() - new Date(t.lastStartISO).getTime());
  }
  t.status = 'stopped';
  t.lastStartISO = null;
  t.endISO = new Date().toISOString();
  save();
}

function deleteTask(i) {
  closeAllDropdowns();
  tasks.splice(i, 1);
  save();
}

/* ---------- Edit Modal (linked to Start/End/Duration) ---------- */
let editingIndex = null;

function toLocalInputValue(isoStr) {
  if (!isoStr) return '';
  const d = new Date(isoStr);
  const pad = (n) => String(n).padStart(2,'0');
  const yyyy = d.getFullYear();
  const mm = pad(d.getMonth()+1);
  const dd = pad(d.getDate());
  const hh = pad(d.getHours());
  const mi = pad(d.getMinutes());
  return `${yyyy}-${mm}-${dd}T${hh}:${mi}`;
}

function fromLocalInputValue(val) {
  if (!val) return null;
  const d = new Date(val); // local time
  if (isNaN(d.getTime())) return null;
  return d.toISOString();
}

function openEdit(i) {
  closeAllDropdowns();
  editingIndex = i;
  const t = tasks[i];

  document.getElementById('editName').value = t.name || '';
  document.getElementById('editCategory').value = t.category || 'Work';
  document.getElementById('editStart').value = toLocalInputValue(t.createdAtISO);
  document.getElementById('editEnd').value = toLocalInputValue(t.endISO);
  document.getElementById('editDuration').value = formatDuration(getDurationMs(t));

  document.getElementById('editBackdrop').classList.add('show');
}

function closeEditModal(evt) {
  if (evt && evt.target && !evt.target.classList.contains('backdrop')) return;
  document.getElementById('editBackdrop').classList.remove('show');
  editingIndex = null;
}

function saveEdit() {
  if (editingIndex === null) return;
  const t = tasks[editingIndex];

  const newName = document.getElementById('editName').value.trim();
  const newCategory = document.getElementById('editCategory').value;
  const startISO = fromLocalInputValue(document.getElementById('editStart').value);
  const endISOInput = fromLocalInputValue(document.getElementById('editEnd').value);
  const durMsInput = parseHHMMSS(document.getElementById('editDuration').value);

  if (!newName) return alert('Task name cannot be empty.');
  if (!startISO) return alert('Start time is invalid.');

  const startMs = new Date(startISO).getTime();

  // Decide how to compute duration/end:
  // - If End provided: duration = End - Start
  // - Else if Duration provided: end = Start + Duration (ONLY if you want a fixed End)
  // - Else: keep as-is (for running/paused, you can leave End blank)
  let newElapsedMs = null;
  let newEndISO = null;

  if (endISOInput) {
    const endMs = new Date(endISOInput).getTime();
    if (endMs < startMs) return alert('End must be after Start.');
    newElapsedMs = endMs - startMs;
    newEndISO = endISOInput;
  } else if (durMsInput !== null) {
    newElapsedMs = durMsInput;
    // only set End automatically if the task is stopped; for running/paused keep End blank
    if (t.status === 'stopped') {
      newEndISO = new Date(startMs + newElapsedMs).toISOString();
    } else {
      newEndISO = null;
    }
  } else {
    // neither end nor duration changed in a valid way
    // keep existing duration/End values
    newElapsedMs = (t.status === 'running')
      ? (t.elapsedMs || 0) // keep base; live running continues
      : (t.elapsedMs || 0);
    newEndISO = t.endISO || null;
  }

  // Apply edits
  t.name = newName;
  t.category = newCategory;
  t.createdAtISO = startISO;

  // Link edit to Duration: store it in elapsedMs
  t.elapsedMs = Math.max(0, newElapsedMs);

  // End handling:
  // - If task is stopped, keep/set End based on edit (or keep existing)
  // - If running/paused, End should be blank unless user explicitly set one (then we stop it)
  if (endISOInput) {
    t.endISO = newEndISO;
    t.status = 'stopped';
    t.lastStartISO = null;
  } else {
    if (t.status === 'stopped') {
      t.endISO = newEndISO || t.endISO || null;
      t.lastStartISO = null;
    } else {
      t.endISO = null;
      // if running, keep it running from now
      if (t.status === 'running') t.lastStartISO = new Date().toISOString();
      if (t.status === 'paused') t.lastStartISO = null;
    }
  }

  save();
  closeEditModal();
}

/* ---------- render ---------- */
function render() {
  const tbody = document.getElementById('tasksTable');
  tbody.innerHTML = '';

  tasks.forEach((t, i) => {
    const startStr = new Date(t.createdAtISO).toLocaleString();
    const endStr = t.endISO ? new Date(t.endISO).toLocaleString() : '-';
    const durationStr = formatDuration(getDurationMs(t));

    // Actions: include pause/resume/stop as needed, ALWAYS include edit/delete
    let menu = '';

    if (t.status === 'running') {
      menu += `<button onclick="pauseTask(${i})">Pause</button><hr>`;
      menu += `<button onclick="stopTask(${i})">Stop</button><hr>`;
    } else if (t.status === 'paused') {
      menu += `<button onclick="resumeTask(${i})">Resume</button><hr>`;
      menu += `<button onclick="stopTask(${i})">Stop</button><hr>`;
    } else {
      // stopped: no pause/resume; still can edit/delete
    }

    menu += `<button onclick="openEdit(${i})">Edit</button><hr>`;
    menu += `<button class="danger" onclick="deleteTask(${i})">Delete</button>`;

    tbody.innerHTML += `
      <tr>
        <td>${t.name}</td>
        <td>${t.category}</td>
        <td>${startStr}</td>
        <td><span id="end-${i}">${endStr}</span></td>
        <td><span id="dur-${i}">${durationStr}</span></td>
        <td>
          <div class="action-wrap">
            <button class="action-btn" onclick="toggleDropdown(${i}); event.stopPropagation()">
              Actions ▾
            </button>
            <div class="dropdown" id="dd-${i}">
              ${menu}
            </div>
          </div>
        </td>
      </tr>
    `;
  });
}

/* live duration update (and end update after stop) */
function tick() {
  tasks.forEach((t, i) => {
    const durEl = document.getElementById(`dur-${i}`);
    if (durEl) durEl.textContent = formatDuration(getDurationMs(t));

    const endEl = document.getElementById(`end-${i}`);
    if (endEl) endEl.textContent = t.endISO ? new Date(t.endISO).toLocaleString() : '-';
  });
}

render();
setInterval(tick, 1000);
</script>
</body>
</html>
